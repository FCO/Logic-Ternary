use Test;
use Logic::Ternary;

my $T = True;
my $F = False;
my $U = Unknown;

# Negation
is-deeply $T.not, $F, 'not3 True -> False (method .not)';
is-deeply not3 $U, $U, 'not3 Unknown -> Unknown (function)';
is-deeply not3 $F, $T, 'not3 False -> True (function)';

# Booleanization
ok $T.Bool, 'Bool(True) is True';
nok $F.Bool, 'Bool(False) is False';
nok $U.Bool, 'Bool(Unknown) is False';

# Coercions
is-deeply  1 .Ternary,  $T, '1.Ternary -> True';
is-deeply -3 .Ternary,  $F, '-3.Ternary -> False';
is-deeply  0 .Ternary,  $U, '0.Ternary -> Unknown';
is-deeply  Bool::True.Ternary,  $T, 'True.Ternary -> True';
is-deeply  Bool::False.Ternary, $F, 'False.Ternary -> False';
is-deeply  Bool.Ternary,  $U, 'Bool.Ternary (type object) -> Unknown';

# and3 (UPPERCASE)
is-deeply $T and3 $T, $T, 'T and3 T -> T';
is-deeply $T and3 $U, $U, 'T and3 U -> U';
is-deeply $T and3 $F, $F, 'T and3 F -> F';
is-deeply $U and3 $T, $U, 'U and3 T -> U';
is-deeply $U and3 $U, $U, 'U and3 U -> U';
is-deeply $U and3 $F, $F, 'U and3 F -> F';
is-deeply $F and3 $T, $F, 'F and3 T -> F';
is-deeply $F and3 $U, $F, 'F and3 U -> F';
is-deeply $F and3 $F, $F, 'F and3 F -> F';

# or3 (UPPERCASE)
is-deeply $T or3 $T, $T, 'T or3 T -> T';
is-deeply $T or3 $U, $T, 'T or3 U -> T';
is-deeply $T or3 $F, $T, 'T or3 F -> T';
is-deeply $U or3 $T, $T, 'U or3 T -> U';
is-deeply $U or3 $U, $U, 'U or3 U -> U';
is-deeply $U or3 $F, $U, 'U or3 F -> U';
is-deeply $F or3 $T, $T, 'F or3 T -> T';
is-deeply $F or3 $U, $U, 'F or3 U -> U';
is-deeply $F or3 $F, $F, 'F or3 F -> F';

# xor3 (UPPERCASE)
is-deeply $T xor3 $T, $F, 'T xor3 T -> F';
is-deeply $T xor3 $F, $T, 'T xor3 F -> T';
is-deeply $F xor3 $F, $F, 'F xor3 F -> F';
is-deeply $U xor3 $F, $U, 'U xor3 F -> U';
is-deeply $U xor3 $U, $U, 'U xor3 U -> U';
is-deeply $U xor3 $T, $U, 'U xor3 T -> U';

# Ternary defined-or (//)
is-deeply $U // $T, $T, 'Unknown // True -> True';
is-deeply $U // $F, $F, 'Unknown // False -> False';
is-deeply $T // $F, $T, 'True // False -> True';
is-deeply $F // $T, $F, 'False // True -> False';
is-deeply Logic::Ternary // $T, $T, 'Type-object // value -> right operand';

# Smartmatch (~~)
ok $T ~~ $T, 'True ~~ True';
nok $T ~~ $U, 'True !~~ Unknown';
ok $F ~~ $F, 'False ~~ False';
ok $U ~~ $U, 'Unknown ~~ Unknown';

done-testing;
